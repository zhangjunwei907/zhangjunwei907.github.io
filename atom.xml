<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhanglinquan.github.io</id>
    <title>张林铨的blog</title>
    <updated>2020-04-03T08:11:26.575Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhanglinquan.github.io"/>
    <link rel="self" href="https://zhanglinquan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zhanglinquan.github.io/images/avatar.png</logo>
    <icon>https://zhanglinquan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 张林铨的blog</rights>
    <entry>
        <title type="html"><![CDATA[题解 SP11515 【BUSYMAN - I AM VERY BUSY】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-sp11515-busyman-i-am-very-busy</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-sp11515-busyman-i-am-very-busy">
        </link>
        <updated>2020-04-03T06:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>这题是特别水的贪心，可以用自动排序的set实现</p>
<p>主要思路：将所有活动按结束时间从小到大排序，能进行活动就进行，遇到不能的就结束</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct data{
    int a,b;
};
class cmp{//比较函数类
	public:
        bool operator()(const data&amp; x,const data&amp; y){
            if(x.b==y.b)//如果结束时间一样就按开始时间排
        		return x.a&lt;y.a;
    		return x.b&lt;y.b;//否则就按结束时间排
        }
};
set&lt;data,cmp&gt; a;//自动按比较函数类排序
int main(){
	int n,t,ans,last;
	cin&gt;&gt;n;
	data tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;t;
		for(int j=1;j&lt;=t;j++){//由于空间大小是set自动分配的，只能先输入临时变量再通过insert函数插入
			cin&gt;&gt;tmp.a&gt;&gt;tmp.b;
			a.insert(tmp);
		}
		set&lt;data&gt;::iterator it=a.begin();//指向开始的迭代器
		ans=0;//初始化
		last=INT_MIN;
		for(;it!=a.end();it++){
			if((*it).a&gt;=last){//来得及
				ans++;//能去的加一
				//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot;eee&quot;&lt;&lt;(*it).a&lt;&lt;&quot; &quot;&lt;&lt;(*it).b&lt;&lt;endl;
				last=(*it).b;//更新上一次的结束时间
				
			}
		}
		cout&lt;&lt;ans&lt;&lt;endl;
		a.clear();//insert会插入，不会覆盖，所以要清空set
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF230A 【Dragons】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf230a-dragons</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf230a-dragons">
        </link>
        <updated>2020-04-03T03:06:09.000Z</updated>
        <content type="html"><![CDATA[<p>用贪心的策略，每次打最小的龙</p>
<p>这里用会自动排序的set实现。具体见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct dr{
	int x,y;//龙的结构体
};
class drcmp{//比较函数类
	public:
        bool operator()(const dr&amp; a,const dr&amp; b){
            return a.x&lt;=b.x;//注意，要&lt;=，不是&lt;
        }
};
set&lt;dr,drcmp&gt; a;//存龙的信息的set，使用自定义比较函数类
int main(){
	int f,n;
	cin&gt;&gt;f&gt;&gt;n;
	dr tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp.x&gt;&gt;tmp.y;//输入临时变量在插入
		a.insert(tmp);
	}
	set&lt;dr&gt;::iterator it=a.begin();//定义指向开头（最小）的迭代器
	for(;it!=a.end();it++){
		if(f&gt;(*it).x) f+=(*it).y;//现有力量值足够，加上额外获得的（访问iterator指向的元素要加*）
		else{//不能，输出，结束
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
			return 0;
		}
	}
	cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//能进入下一层
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF892A 【Greed】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf892a-greed</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf892a-greed">
        </link>
        <updated>2020-04-02T13:06:28.000Z</updated>
        <content type="html"><![CDATA[<p>把所有可乐倒进2个罐子里，那么肯定是选最大的两个罐子，再和总可乐数比较即可。</p>
<p>要自动排序又不会去重的数据结构当然选multiset</p>
<p>具体用法见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
multiset&lt;int&gt; a;//自动从小到大排序但不会去重的数据结构
int main(){
	long long tmp,n,sum=0;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;//输入可乐数并累加
		sum+=tmp;
	}
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;////由于空间大小是multiset自动分配的，只能先输入临时变量再通过insert函数插入
		a.insert(tmp);
	}
	multiset&lt;int&gt;::iterator it=a.end();//因为是从小到大排序，所以最大的在结尾处
	it--;//.end()函数返回的iterator是最后一个元素还要后面一个，所以真正最大的要-1，但multiset::iterator不支持除++和--以外的运算，所以用--运算
	multiset&lt;int&gt;::iterator it2=it;//第二大
	it2--;//同上
	if(sum&lt;=(*it+*it2)) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//装得下（访问iterator指向的元素要加*）
	else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//装不下
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF653A 【Bear and Three Balls】]]></title>
        <id>https://zhanglinquan.github.io/post/ben-xiao-xue-sheng-ju-ruo-de-di-yi-pian-ti-jie</id>
        <link href="https://zhanglinquan.github.io/post/ben-xiao-xue-sheng-ju-ruo-de-di-yi-pian-ti-jie">
        </link>
        <updated>2020-04-02T06:45:44.000Z</updated>
        <content type="html"><![CDATA[<p>思路：排序+去重，判断是否有连续的三个数</p>
<p>看到既要排序还要去重，当然用set啦</p>
<p>具体解释见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
set&lt;int&gt; a;//这是一个自动排序+去重的数据结构
int main(){
	int n;
	cin&gt;&gt;n;
	int tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;//由于空间大小是set自动分配的，只能先输入临时变量再通过insert函数插入
		a.insert(tmp);
	}
	set&lt;int&gt;::iterator ed=a.end();//不直接用.end()的原因看下面for语句的解释
	ed--;//由于set::iterator不能用-=运算符，只能分两次--
	ed--;
	for(set&lt;int&gt;::iterator it=a.begin();it!=ed;it++){//it为a.end()时it+1和+2处会越界，所以用前面相当于a.end()-2的iterator做边界
		set&lt;int&gt;::iterator it2=it;//it+1，因为set::iterator不支持+=或+，所以定义两个iterator分别代表it+1和it+2
		it2++;
		set&lt;int&gt;::iterator it3=it2;//it+2，理由同上
		it3++;
		if(*it+1==*it2&amp;&amp;*it2+1==*it3){//判断是否为连续三个数（访问iterator指向的元素要加*）
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//满足
			return 0;//结束
		}
	}
	cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//不满足
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神虎牌删犇器]]></title>
        <id>https://zhanglinquan.github.io/post/shen-hu-pai-shan-ben-qi</id>
        <link href="https://zhanglinquan.github.io/post/shen-hu-pai-shan-ben-qi">
        </link>
        <updated>2020-03-28T09:55:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="操作步骤">操作步骤</h2>
<ol>
<li>
<p>按下键盘上的 <code>f12</code> 按键。</p>
</li>
<li>
<p>在右方控制栏中点击 <code>Console</code> 会出现可以输入的区域。</p>
</li>
<li>
<p>输入下方的这段代码。</p>
</li>
</ol>
<pre><code class="language-cpp">switchMode('my');
function load() {
	console.log('page ' + feedPage);
	$.get(&quot;/feed/&quot; + feedMode + &quot;?page=&quot; + feedPage, function (resp) {
		$feed.append(resp);
		$(&quot;#feed-more&quot;).children(&quot;a&quot;).text(&quot;点击查看更多...&quot;)
		$(&quot;[name=feed-delete]&quot;).click(function () {
			$.post(&quot;/api/feed/delete/&quot; + $(this).attr('data-feed-id'), function () {
				switchMode('all');
			})
		}); feedPage++;
		if (resp.indexOf('没有更多动态了') != -1) console.log('finished');
		else setTimeout(load, 200);
	});
}
setTimeout(load, 1000)
</code></pre>
<ol start="4">
<li>
<p>接着回车 <code>enter</code> 即可。</p>
</li>
<li>
<p>马上会出现一大串的数字，慢慢等待 <code>Page</code> 闪完后出现 <code>finish</code>。</p>
</li>
</ol>
<p>接着输入以下代码：</p>
<pre><code class="language-cpp">var l =  $('#feed &gt; li &gt; div.am-comment-main &gt; header &gt; div &gt; a:nth-child(2)');
function f(i) {
$ .post(&quot;/api/feed/delete/&quot;+ $(l[i]).attr('data-feed-id'), function() {
console.log(i);
if(i&lt;l.length-1)setTimeout(`f(${i+1})`,200);
})
}
f(0);
</code></pre>
<ol start="6">
<li>如果出现 <code>503</code> 界面重新再次<strong>重复上述过程</strong>。</li>
</ol>
<p>直到删完为止，重新加载整个界面，建议重启浏览器。</p>
<p>最后就完成了删犇的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于BFS]]></title>
        <id>https://zhanglinquan.github.io/post/about-bfs</id>
        <link href="https://zhanglinquan.github.io/post/about-bfs">
        </link>
        <updated>2020-03-06T12:57:43.000Z</updated>
        <content type="html"><![CDATA[<p><s>他死了</s><br>
BFS，即宽度优先搜索（balabala不讲无意义内容）<br>
核心：用一个队列来记录“待办事项”，用最短路来举个例子，代码如下</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int dx[5]={0,1,0,0,-1};
int dy[5]={0,0,-1,1,0};
int a[1001][1001],q[250000][10];
int sx,sy,ex,ey;
void input(int n,int m){
	char tmp;
	memset(a,-1,sizeof(a));
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;tmp;
			if(tmp=='.') a[i][j]=0;
			if(tmp=='#') a[i][j]=-1;
			if(tmp=='*'){
				a[i][j]=0;
				ex=i;
				ey=j;
			}
			if(tmp=='@'){
				a[i][j]=0;
				sx=i;
				sy=j;
			}
		}
	}
}
int main(){
	int h=1,t=1,n,m;
	cin&gt;&gt;n&gt;&gt;m;
	input(n,m);
	q[1][0]=0;
	q[1][1]=sx;//初始化“待办事项
	q[1][2]=sy;//同上
	a[1][1]=-1;
	while(h&lt;=t){
		if(q[h][1]==ex&amp;&amp;q[h][2]==ey){//达到目标
			cout&lt;&lt;q[h][0]&lt;&lt;endl;
			return 0;
		}
		for(int i=1;i&lt;=4;i++){
			int x,y;
			x=q[h][1]+dx[i];//拿到事情
			y=q[h][2]+dy[i];//同上
			if(a[x][y]==0){//做事
				t++;
				q[t][0]=q[h][0]+1;//产生新事
				q[t][1]=x;//同上
				q[t][2]=y;//同上
				a[x][y]=-1;
			}
		}
		h++;//做完了一件事
	}
    //无解
	return 0;
}
</code></pre>
<p>这里面没有用STL中的queue，但原理相同。<br>
代码中每次穷举的是步数（即离终点的距离），一次while穷举一个步数。<br>
可以看到，队列在while循环做完之前不为空（即有效解一定在穷举完所有步数之前得到），所以BFS的解一般是在循环内产生。<br>
然后，我们用深搜（DFS）来实现一下</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[105][105],d[105][105],n,m;
void dg(int dep,int i,int j){
	if(dep&lt;d[i][j]&amp;&amp;dep&lt;200){
		d[i][j]=dep;
		if(a[i][j+1]==0) dg(dep+1,i,j+1);
		if(a[i+1][j]==0) dg(dep+1,i+1,j);
		if(a[i][j-1]==0) dg(dep+1,i,j-1);
		if(a[i-1][j]==0) dg(dep+1,i-1,j);
	}
}
void input(int n,int m){
	char tmp;
	memset(a,-1,sizeof(a));
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;tmp;
			if(tmp=='.') a[i][j]=0;
			if(tmp=='#') a[i][j]=-1;
			d[i][j]=INT_MAX;
		}
	}
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	input(n,m);
	dg(1,1,1);
	cout&lt;&lt;d[n][m]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>可以发现，DFS慢在于需要回溯，而且不做到底不回头，举个例子，正确路径是右右右右，而DFS永远先穷举左，产生大量无意义劳动，而BFS只需要循环4*4=16次，速度进步巨大。（所以DFS要加玄学限制:dep&lt;200）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次做工程的成果]]></title>
        <id>https://zhanglinquan.github.io/post/di-yi-ci-zuo-gong-cheng-de-cheng-guo</id>
        <link href="https://zhanglinquan.github.io/post/di-yi-ci-zuo-gong-cheng-de-cheng-guo">
        </link>
        <updated>2020-03-05T12:08:02.000Z</updated>
        <content type="html"><![CDATA[<p>寒假里摸鱼的成果</p>
<pre><code class="language-cpp">/*
坑点大全：
1.地图是25*25的，不是27*27的
2.x,y是行，列，不是列，行（可能某些地方做了转换） 
3.p1在代码中还记作p1，但p2记作p0
4.p2(p0)代码中变量为p1的后面加数字1
5.重要！！重要！！！！重要！！！这个程序分4个线程，分别是打印地图，main函数，p1键盘侦测，p2（p0）键盘侦测
6.原来想做的事战略游戏（放置方块）（像皇室战争）所以障碍才分1-4，1、2归P1，3、4归P2，后来改成走迷宫，添加了6目标方块，还可以放障碍（1-4），后来变成放地雷，再变成自动生成地雷，最后水平不足，变成
自动生成障碍。
7.请未来的自己帮忙，其实自动行走是bug。（2020.1.25） 
*/ 
#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt; 
#include&lt;time.h&gt;
COORD coord;
using namespace std;
const int mapx=27;
bool stop=false;
int maps[mapx][mapx];
HANDLE hCon;
int p1ott,p1btt,p2ott,p2btt,pn=1,x=2,y=2,ops,ops1,x1=2,y1=2;
enum Color {DARKBLUE=1,DARKGREEN,DARKTEAL,DARKRED,DARKPINK,DARKYELLOW,GRAY,DARKGRAY,BLUE,GREEN,TEAL,RED,PINK,YELLOW,WHITE};
void window(){
	HANDLE handle=GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_CURSOR_INFO CursorInfo;
	GetConsoleCursorInfo(handle,&amp;CursorInfo);
	CursorInfo.bVisible=false;
	SetConsoleCursorInfo(handle,&amp;CursorInfo); 
}
void SetColor(Color c){
    if(hCon==NULL)
    	hCon=GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hCon,c);
}
void GoToxy(int x,int y){
    coord.X=x;
    coord.Y=y;
    HANDLE a=GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleCursorPosition(a,coord);
}
int clrscr(){ 
	HANDLE hndl=GetStdHandle(STD_OUTPUT_HANDLE); 
	CONSOLE_SCREEN_BUFFER_INFO csbi; 
	GetConsoleScreenBufferInfo(hndl,&amp;csbi); 
	DWORD written; 
	DWORD N=csbi.dwSize.X*csbi.dwCursorPosition.Y+csbi.dwCursorPosition.X+1; 
	COORD curhome={0,0}; 
	FillConsoleOutputCharacter(hndl,' ',N,curhome,&amp;written); 
	csbi.srWindow.Bottom-=csbi.srWindow.Top; 
	csbi.srWindow.Top=0; 
	SetConsoleWindowInfo(hndl,TRUE,&amp;csbi.srWindow); 
	SetConsoleCursorPosition(hndl,curhome); 
	return 0; 
}
char keyboard(){
	if (GetAsyncKeyState(VK_UP)&amp;0x8000)  
		return 'w';
    else if (GetAsyncKeyState(VK_DOWN)&amp;0x8000)  
		return 's';
    else if (GetAsyncKeyState(VK_LEFT)&amp;0x8000)
        return 'a';
    else if (GetAsyncKeyState(VK_RIGHT)&amp;0x8000)  
        return 'd';
    else if (GetAsyncKeyState(VK_NUMPAD8)&amp;0x8000)  
        return 'i';
    else if (GetAsyncKeyState(VK_NUMPAD5)&amp;0x8000)  
    	return 'k';
    else if (GetAsyncKeyState(VK_NUMPAD4)&amp;0x8000)
        return 'j';
    else if (GetAsyncKeyState(VK_NUMPAD6)&amp;0x8000)  
        return 'l';
}
char to_ch_map(int n){
	switch(n){
		case 0:return '.';
		case 1:return '@';
		case 2:return '#';
		case 3:return '$';
		case 4:return '%';
		case 5:return '=';
		case 6:return '*';
		case 7:return '&amp;';
	}
}
void outputmap(){
	int c;
	char c2;
	char op;
	for(int i=1;i&lt;mapx;i++){
		for(int j=1;j&lt;mapx;j++){
			GoToxy(j,i);
			c=maps[i][j];
			c2=to_ch_map(c);
			if(maps[i][j]==5||maps[i][j]==7){
				SetColor(RED);
			}
			printf(&quot;%c&quot;,c2);
			SetColor(YELLOW);
		}
		printf(&quot;\n&quot;);
	}
}
void p1(){
	char op;
	int oops=ops;
	int ox=1,oy=1,th;
	ox=x;oy=y;
	op=keyboard();
	switch(op){
		case 'w':x--;ops=0;break;
		case 's':x++;ops=0;break;
		case 'a':y--;ops=0;break;
		case 'd':y++;ops=0;break;
	}
	if(maps[x][y]!=0&amp;&amp;maps[x][y]!=6){
		x=ox;
		y=oy;
	}
	if(oops==0&amp;&amp;ops==0) maps[ox][oy]=0;
	if(ops==0) maps[x][y]=5;
}
void p2(){
	char op1;
	int oops1=ops1;
	int ox1=1,oy1=1,th1;
	ox1=x1;oy1=y1;
	op1=keyboard();
	switch(op1){
		case 'i':x1--;ops=0;break;
		case 'k':x1++;ops=0;break;
		case 'j':y1--;ops=0;break;
		case 'l':y1++;ops=0;break;
	}
	if(maps[x1][y1]!=0&amp;&amp;maps[x1][y1]!=6){
		x1=ox1;
		y1=oy1;
	}
	if(oops1==0&amp;&amp;ops1==0) maps[ox1][oy1]=0;
	if(ops1==0) maps[x1][y1]=7;
}
void start(){
	srand(time(0));
	memset(maps,rand(),sizeof(maps));
	memset(maps,0,sizeof(maps));
	maps[11][11]=6;
	maps[10][1]=1;
	maps[11][1]=1;
	maps[8][2]=1;
	maps[13][2]=1;
	maps[10][mapx-2]=1;
	maps[11][mapx-2]=1;
	maps[8][mapx-1]=1;
	maps[13][mapx-1]=1;
	maps[11][10]=2;
	maps[11][12]=2;
	maps[10][11]=2;
	for(int i=1;i&lt;=mapx-1;i++){
		maps[1][i]=2;
		maps[i][1]=2;
	}
	for(int i=1;i&lt;=mapx-1;i++){
		maps[i][mapx-1]=2;
		maps[mapx-1][i]=2;
	}
	srand(time(0));
	for(int i=1;i&lt;mapx-1;i++){
		for(int j=1;j&lt;mapx-1;j++){
			if(j==11||i==11) continue;
			if(rand()%10==0) maps[i][j]==4;
			if(rand()%13==0) maps[i][j]=1;
			if(rand()%75==0) maps[i][j]=3;
		}
	}
}
void th1(){
	while(!stop){
		outputmap();
	}
	clrscr();
	system(&quot;color C4&quot;);
}
void th2(){
	while(!stop){
		p2();
		Sleep(100);
	}
	clrscr();
	system(&quot;color C4&quot;);
}
void th3(){
	while(!stop){
		p1();
		Sleep(100);
	}
	clrscr();
	system(&quot;color C4&quot;);
}
int main(){
	window();
	start();
	thread t(&amp;th1);
	thread t1(&amp;th2);
	thread t3(&amp;th3);
	while(!stop){
		if(maps[11][11]!=5&amp;&amp;maps[11][11]!=7&amp;&amp;maps[11][11]!=6){
			maps[11][11]=6;
			cout&lt;&lt;&quot;this block must be 6!!&quot;&lt;&lt;endl;
		}
		if(maps[11][11]==5){
			stop=!stop;
			clrscr();
			Sleep(1000);
			system(&quot;color 07&quot;);
			cout&lt;&lt;&quot;p1 WIN&quot;&lt;&lt;endl;
			system(&quot;pause&quot;);
			exit(0);
		}
		if(maps[11][11]==7){
			stop=!stop;
			clrscr();
			Sleep(1000);
			system(&quot;color 07&quot;);
			cout&lt;&lt;&quot;p2 WIN&quot;&lt;&lt;endl;
			system(&quot;pause&quot;);
			exit(0);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从记忆化搜索到DP（动态规划）]]></title>
        <id>https://zhanglinquan.github.io/post/cong-ji-yi-hua-sou-suo-sou-suo-dao-dpdong-tai-gui-hua</id>
        <link href="https://zhanglinquan.github.io/post/cong-ji-yi-hua-sou-suo-sou-suo-dao-dpdong-tai-gui-hua">
        </link>
        <updated>2020-02-19T13:01:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录">目录</h1>
<ul>
<li>记忆化搜索是啥</li>
<li>记忆化搜索和动态规划有啥关系</li>
<li>动态规划做法</li>
</ul>
<h1 id="1-记忆化搜索是啥引入">1. 记忆化搜索是啥（引入</h1>
<p>好，就以采药这道题为例，我不会动态规划，只会搜索，我就会直接写一个粗暴的 DFS :</p>
<p>注: 为了方便食用, 本文中所有代码省略头文件</p>
<pre><code class="language-cpp">int n,t;
int tcost[103],mget[103];
int ans=0;
void dfs(int pos,int tleft,int tans){
    if(tleft&lt;0) return;
    if(pos==n+1){
        ans=max(ans,tans);
        return;
    }
    dfs(pos+1,tleft,tans);
    dfs(pos+1,tleft-tcost[pos],tans+mget[pos]);
}
int main(){
    cin&gt;&gt;t&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;tcost[i]&gt;&gt;mget[i];
    dfs(1,t,0);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>30pts</p>
<p>然后我心血来潮, 想不借助任何 &quot;外部变量&quot;(就是 dfs 函数外且 值随 dfs 运行而改变的变量 ), 比如 ans</p>
<p>把 ans 删了之后就有一个问题: 我们拿什么来记录答案?</p>
<p>答案很简单:</p>
<p>返回值!</p>
<p>此时 dfs(pos,tleft) 返回在时间 tleft内采集 后 pos 个草药, 能获得的最大收益</p>
<p>不理解就看看代码吧:</p>
<pre><code class="language-cpp">int n,time;
int tcost[103],mget[103];
int dfs(int pos,int tleft){
    if(pos==n+1)
        return 0;
    int dfs1,dfs2=-INF;
    dfs1=dfs(pos+1,tleft);
    if( tleft&gt;tcost[pos] )
        dfs2=dfs(pos+1,tleft-tcost[pos])+mget[pos];
    return max(dfs1,dfs2);
}
int main(){
    cin&gt;&gt;time&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;tcost[i]&gt;&gt;mget[i];
    cout&lt;&lt;dfs(1,time)&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><s>还是30pts，我太难了</s><br>
但这个时候, 我们的程序已经不依赖任何外部变量了.</p>
<p>然后我非常无聊, 将所有 dfs 的返回值都记录下来, 竟然发现......</p>
<pre><code>震惊, 对于相同的 pos 和 tleft,dfs 的返回值总是相同的!
</code></pre>
<p>想一想也不奇怪, 因为我们的 dfs 没有依赖任何外部变量.</p>
<p>旁白: 像 tcost[103],mget[103] 这种东西不算是外部变量, 因为她们在 dfs 过程中不变.</p>
<p>然后?</p>
<p>开个数组 mem , 记录下来每个 dfs(pos,tleft) 的返回值. 刚开始把 mem 中每个值都设成 -1 (代表没访问过). 每次刚刚进入一个 dfs 前(我们的 dfs 是递归调用的嘛), 都检测 mem[pos][tleft]是否为 -1 , 如果是就正常执行并把答案记录到 mem 中, 否则?</p>
<p>直接返回 mem 中的值!</p>
<pre><code class="language-cpp">int n,t;
int tcost[103],mget[103];
int mem[103][1003];
int dfs(int pos,int tleft){
    if(mem[pos][tleft]!=-1) return mem[pos][tleft];
    if(pos==n+1)
        return mem[pos][tleft] = 0;
    int dfs1,dfs2=-INF;
    dfs1 = dfs(pos+1,tleft);
    if(tleft&gt;=tcost[pos])
        dfs2=dfs(pos+1,tleft-tcost[pos])+mget[pos];
    return mem[pos][tleft]=max(dfs1,dfs2);
}
int main(){
    memset(mem,-1,sizeof(mem));
    cin&gt;&gt;t&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;tcost[i]&gt;&gt;mget[i];
    cout&lt;&lt;dfs(1,t)&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>此时 mem 的意义与 dfs 相同：</p>
<pre><code>在时间 tleft内采集 后 pos 个草药, 能获得的最大收益
</code></pre>
<p>这能 ac?</p>
<p>能. 这就是 &quot;采药&quot; 那题的 AC 代码</p>
<p>好我们倒腾出了记忆化搜索</p>
<p>总结一下记忆化搜索是啥:<br>
不依赖任何 外部变量，答案以返回值的形式存在, 而不能以参数的形式存在(就是不能将 dfs 定义成 dfs(pos,tleft,nowans ), 这里面的 nowans 不符合要求).</p>
<p>对于相同一组参数, dfs 返回值总是相同的</p>
<h1 id="记忆化搜索与动态规划的关系分析">记忆化搜索与动态规划的关系:（分析</h1>
<p>基本是朋 (ji) 友关系</p>
<p>有人会问: 记忆化搜索难道不是搜索?</p>
<p>一定程度上来说，她是搜索.但个人认为她更像dp</p>
<p>其实说白了，记忆化搜索就是dp</p>
<p>不信你看mem 的意义:</p>
<p>在时间 tleft 内采集 后 pos 个草药, 能获得的最大收益</p>
<p>这不就是dp的状态?</p>
<p>由上面的代码中可以看出:</p>
<p>dfs(pos,left) = max(dfs(pos+1,tleft-tcost[pos])+mget[pos] , dfs(pos+1,tleft))<br>
即为</p>
<p>mem[pos][tleft] = max(mem[pos+1][tleft-tcost[pos]]+mget[pos] , mem[pos+1][tleft])<br>
这不就是dp的状态转移?</p>
<p>总结一下：</p>
<pre><code>记忆化搜索和动态规划从根本上来讲就是一个东西,**(印象中)任何一个 dp 方程都能转为记忆化搜索 ，反之亦然（为什么？见下文“体现在”的第四条）
</code></pre>
<p>体现在</p>
<ul>
<li>
<p>根据记忆化搜索的参数可以直接得到dp的状态，反之亦然</p>
</li>
<li>
<p>根据记忆化搜索的递归关系可以写出状态转移方程，这个方程可以直接写出循环式的dp，只不过是反的(想想为什么？)，反之亦然</p>
</li>
<li>
<p>大部分记忆化搜索时空复杂度与 不加优化的 dp 完全相同</p>
</li>
<li>
<p><strong>最重要的一点：二者思想类似！！ 核心思想均为：利用对于相同参数答案相同的特性，对于相同的参数（循环式的dp体现为数组下标），记录其答案，免去重复计算，从而起到优化时间复杂度的作用。这，便是二者的精髓。</strong></p>
</li>
</ul>
<p>建议好好想想第四条。记住，学一个算法，一定要理解他的精髓。</p>
<p>举个栗子:</p>
<p>dp[i][j][k] = dp[i+1][j+1][k-a[j]] + dp[i+1][j][k]<br>
转为</p>
<pre><code class="language-cpp">int dfs(int i,int j,int k){
    边界条件
    if( mem[i][j][k]!=-1) return mem[i][j][k];
    return mem[i][j][k]=dfs(i+1,j+1,k-a[j])+dfs(i+1,j,k);
}
int main(){
    memset(mem,-1,sizeof(mem));
    读入
    cout&lt;&lt;dfs(1,0,0)&lt;&lt;endl;
}
</code></pre>
<p>二者满足上面提到的所有关系</p>
<h1 id="dp做法">dp做法</h1>
<p><s>上面转移方程都出来了，还不会？？</s></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
int f[1001],n,t,v[101],w[101];
int main(){
    cin&gt;&gt;t&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;w[i]&gt;&gt;v[i];
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=t;j&gt;=w[i];j--) {
            f[j]=max(f[j-w[i]]+v[i], f[j]);
        }
    }
    cout&lt;&lt;f[t];
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归]]></title>
        <id>https://zhanglinquan.github.io/post/递归</id>
        <link href="https://zhanglinquan.github.io/post/递归">
        </link>
        <updated>2019-10-24T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>这节课学了递归，<s>好晕</s></p>
<p>好不容易想通了一点赶紧记下，充当第一篇博客</p>
<p>递归就是函数自己调用自己的过程。那为什么要有递归呢？原因很简单：在解决一个问题的同时，需要解决另一个与当前问题相同的问题，并且这个问题在特定情况下有解（递归结束条件），其他情况的答案都可由此答案推导而来（转移方程）。那又有问题了，为什么不用循环呢？观察上面的描述中“需要解决另一个与当前问题相同的问题”这一句话，真的只需要解决另一个吗？答案是否定的，有可能要解决多个同样的问题，这种情况下，如果使用循环，那么每个循环都要产生多个同样的循环，是无法实现的，所以才要使用递归。</p>
]]></content>
    </entry>
</feed>