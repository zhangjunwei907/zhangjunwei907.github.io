<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhanglinquan.github.io</id>
    <title>yuygfgg的blog</title>
    <updated>2020-04-09T14:15:46.248Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhanglinquan.github.io"/>
    <link rel="self" href="https://zhanglinquan.github.io/atom.xml"/>
    <subtitle>珂朵莉，珂爱</subtitle>
    <logo>https://zhanglinquan.github.io/images/avatar.png</logo>
    <icon>https://zhanglinquan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, yuygfgg的blog</rights>
    <entry>
        <title type="html"><![CDATA[题解 AT2654 【[ARC078A] Splitting Pile】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-at2654-arc078a-splitting-pile</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-at2654-arc078a-splitting-pile">
        </link>
        <updated>2020-04-04T09:55:55.000Z</updated>
        <content type="html"><![CDATA[<p>思路：暴力求出所有可能，排序求最小绝对值差。</p>
<p>我用vector存储卡的信息，用set排序</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;long long&gt; a;
set&lt;long long&gt; b;//自动从小到大排序
long long s=0,x,y;
int main(){
	int n,tmp;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;//由于空间大小不定，只能用push_back函数放入
		a.push_back(tmp);
		s+=tmp;
	}
    //现在开始空间大小一定，可以用从0开始的下标访问
	x=a[0];
	y=s-a[0];
	b.insert(abs(x-y));//插入第一个
	for (int i=1;i&lt;n-1;i++){
		x+=a[i];
		y-=a[i];
		b.insert(abs(x-y));//插入set
	}
	cout&lt;&lt;*b.begin()&lt;&lt;endl;//输出自动排序好的最小数
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF149A 【Business trip】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf149a-business-trip</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf149a-business-trip">
        </link>
        <updated>2020-04-04T01:42:09.000Z</updated>
        <content type="html"><![CDATA[<p><strong>宣传本人<a href="http://yuygfgg.tk">博客</a></strong></p>
<p>思路：贪心。要让浇水的月份最少，就要让每个浇水月收益最大，所以做法是先将每个月的收益从大到小排序，尽量在收益大的月份浇水。</p>
<p>用multiset排序，每次取第i大累加直到满足要求即可</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
multiset&lt;int&gt; a;
int main(){
	int n,tmp,d=0,s=0,k;
	cin&gt;&gt;k;
	for(int i=1;i&lt;=12;i++){
		cin&gt;&gt;tmp;//输入临时变量再插入
		a.insert(tmp);
	}
	if(k==0){//目标为0的话直接输出0
		cout&lt;&lt;0&lt;&lt;endl;
		return 0;
	}
	set&lt;int&gt;::iterator it=a.end();//指向最大值的iterator
	it--;//.end()指向的是最大值还要后面一个，所以要--
	for(;it!=a.begin();it--){
		d+=*it;
		s++;
		if(d&gt;=k){//完成
			cout&lt;&lt;s&lt;&lt;endl;
			return 0;
		}
	}
	d+=*it;//如果不补一次循环，第一个元素不会被遍历到
	s++;
	if(d&gt;=k){//完成
		cout&lt;&lt;s&lt;&lt;endl;
		return 0;
	}
	cout&lt;&lt;-1&lt;&lt;endl;//无法完成目标
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF919A 【Supermarket】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf919a-supermarket</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf919a-supermarket">
        </link>
        <updated>2020-04-03T12:45:37.000Z</updated>
        <content type="html"><![CDATA[<p>思路：贪心，找单价最便宜的超市买即可</p>
<p>用set从小到大排序</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
set&lt;long double&gt; c;//自动从小到大排序
int main(){
    int m,n;
    int a,b;
    cin&gt;&gt;m&gt;&gt;n;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;a&gt;&gt;b;
        long double tmp=((long double)a/b);
        c.insert(tmp*n*1.0);//插入（*1.0用来强制类型转换，否则插入set的数是向下取整的int）
    }
    set&lt;long double&gt;::iterator it=c.begin();//最便宜超市的单价
    cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;*it&lt;&lt;endl;//保留十位
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 SP11515 【BUSYMAN - I AM VERY BUSY】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-sp11515-busyman-i-am-very-busy</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-sp11515-busyman-i-am-very-busy">
        </link>
        <updated>2020-04-03T06:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>这题是特别水的贪心，可以用自动排序的set实现</p>
<p>主要思路：将所有活动按结束时间从小到大排序，能进行活动就进行，遇到不能的就结束</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct data{
    int a,b;
};
class cmp{//比较函数类
	public:
        bool operator()(const data&amp; x,const data&amp; y){
            if(x.b==y.b)//如果结束时间一样就按开始时间排
        		return x.a&lt;y.a;
    		return x.b&lt;y.b;//否则就按结束时间排
        }
};
set&lt;data,cmp&gt; a;//自动按比较函数类排序
int main(){
	int n,t,ans,last;
	cin&gt;&gt;n;
	data tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;t;
		for(int j=1;j&lt;=t;j++){//由于空间大小是set自动分配的，只能先输入临时变量再通过insert函数插入
			cin&gt;&gt;tmp.a&gt;&gt;tmp.b;
			a.insert(tmp);
		}
		set&lt;data&gt;::iterator it=a.begin();//指向开始的迭代器
		ans=0;//初始化
		last=INT_MIN;
		for(;it!=a.end();it++){
			if((*it).a&gt;=last){//来得及
				ans++;//能去的加一
				//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot;eee&quot;&lt;&lt;(*it).a&lt;&lt;&quot; &quot;&lt;&lt;(*it).b&lt;&lt;endl;
				last=(*it).b;//更新上一次的结束时间
				
			}
		}
		cout&lt;&lt;ans&lt;&lt;endl;
		a.clear();//insert会插入，不会覆盖，所以要清空set
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF230A 【Dragons】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf230a-dragons</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf230a-dragons">
        </link>
        <updated>2020-04-03T03:06:09.000Z</updated>
        <content type="html"><![CDATA[<p>用贪心的策略，每次打最小的龙</p>
<p>这里用会自动排序的set实现。具体见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct dr{
	int x,y;//龙的结构体
};
class drcmp{//比较函数类
	public:
        bool operator()(const dr&amp; a,const dr&amp; b){
            return a.x&lt;=b.x;//注意，要&lt;=，不是&lt;
        }
};
set&lt;dr,drcmp&gt; a;//存龙的信息的set，使用自定义比较函数类
int main(){
	int f,n;
	cin&gt;&gt;f&gt;&gt;n;
	dr tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp.x&gt;&gt;tmp.y;//输入临时变量在插入
		a.insert(tmp);
	}
	set&lt;dr&gt;::iterator it=a.begin();//定义指向开头（最小）的迭代器
	for(;it!=a.end();it++){
		if(f&gt;(*it).x) f+=(*it).y;//现有力量值足够，加上额外获得的（访问iterator指向的元素要加*）
		else{//不能，输出，结束
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
			return 0;
		}
	}
	cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//能进入下一层
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF892A 【Greed】]]></title>
        <id>https://zhanglinquan.github.io/post/ti-jie-cf892a-greed</id>
        <link href="https://zhanglinquan.github.io/post/ti-jie-cf892a-greed">
        </link>
        <updated>2020-04-02T13:06:28.000Z</updated>
        <content type="html"><![CDATA[<p>把所有可乐倒进2个罐子里，那么肯定是选最大的两个罐子，再和总可乐数比较即可。</p>
<p>要自动排序又不会去重的数据结构当然选multiset</p>
<p>具体用法见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
multiset&lt;int&gt; a;//自动从小到大排序但不会去重的数据结构
int main(){
	long long tmp,n,sum=0;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;//输入可乐数并累加
		sum+=tmp;
	}
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;////由于空间大小是multiset自动分配的，只能先输入临时变量再通过insert函数插入
		a.insert(tmp);
	}
	multiset&lt;int&gt;::iterator it=a.end();//因为是从小到大排序，所以最大的在结尾处
	it--;//.end()函数返回的iterator是最后一个元素还要后面一个，所以真正最大的要-1，但multiset::iterator不支持除++和--以外的运算，所以用--运算
	multiset&lt;int&gt;::iterator it2=it;//第二大
	it2--;//同上
	if(sum&lt;=(*it+*it2)) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//装得下（访问iterator指向的元素要加*）
	else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//装不下
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF653A 【Bear and Three Balls】]]></title>
        <id>https://zhanglinquan.github.io/post/ben-xiao-xue-sheng-ju-ruo-de-di-yi-pian-ti-jie</id>
        <link href="https://zhanglinquan.github.io/post/ben-xiao-xue-sheng-ju-ruo-de-di-yi-pian-ti-jie">
        </link>
        <updated>2020-04-02T06:45:44.000Z</updated>
        <content type="html"><![CDATA[<p>思路：排序+去重，判断是否有连续的三个数</p>
<p>看到既要排序还要去重，当然用set啦</p>
<p>具体解释见代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
set&lt;int&gt; a;//这是一个自动排序+去重的数据结构
int main(){
	int n;
	cin&gt;&gt;n;
	int tmp;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tmp;//由于空间大小是set自动分配的，只能先输入临时变量再通过insert函数插入
		a.insert(tmp);
	}
	set&lt;int&gt;::iterator ed=a.end();//不直接用.end()的原因看下面for语句的解释
	ed--;//由于set::iterator不能用-=运算符，只能分两次--
	ed--;
	for(set&lt;int&gt;::iterator it=a.begin();it!=ed;it++){//it为a.end()时it+1和+2处会越界，所以用前面相当于a.end()-2的iterator做边界
		set&lt;int&gt;::iterator it2=it;//it+1，因为set::iterator不支持+=或+，所以定义两个iterator分别代表it+1和it+2
		it2++;
		set&lt;int&gt;::iterator it3=it2;//it+2，理由同上
		it3++;
		if(*it+1==*it2&amp;&amp;*it2+1==*it3){//判断是否为连续三个数（访问iterator指向的元素要加*）
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//满足
			return 0;//结束
		}
	}
	cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//不满足
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神虎牌删犇器]]></title>
        <id>https://zhanglinquan.github.io/post/shen-hu-pai-shan-ben-qi</id>
        <link href="https://zhanglinquan.github.io/post/shen-hu-pai-shan-ben-qi">
        </link>
        <updated>2020-03-28T09:55:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="操作步骤">操作步骤</h2>
<ol>
<li>
<p>按下键盘上的 <code>f12</code> 按键。</p>
</li>
<li>
<p>在右方控制栏中点击 <code>Console</code> 会出现可以输入的区域。</p>
</li>
<li>
<p>输入下方的这段代码。</p>
</li>
</ol>
<pre><code class="language-cpp">switchMode('my');
function load() {
	console.log('page ' + feedPage);
	$.get(&quot;/feed/&quot; + feedMode + &quot;?page=&quot; + feedPage, function (resp) {
		$feed.append(resp);
		$(&quot;#feed-more&quot;).children(&quot;a&quot;).text(&quot;点击查看更多...&quot;)
		$(&quot;[name=feed-delete]&quot;).click(function () {
			$.post(&quot;/api/feed/delete/&quot; + $(this).attr('data-feed-id'), function () {
				switchMode('all');
			})
		}); feedPage++;
		if (resp.indexOf('没有更多动态了') != -1) console.log('finished');
		else setTimeout(load, 200);
	});
}
setTimeout(load, 1000)
</code></pre>
<ol start="4">
<li>
<p>接着回车 <code>enter</code> 即可。</p>
</li>
<li>
<p>马上会出现一大串的数字，慢慢等待 <code>Page</code> 闪完后出现 <code>finish</code>。</p>
</li>
</ol>
<p>接着输入以下代码：</p>
<pre><code class="language-cpp">var l =  $('#feed &gt; li &gt; div.am-comment-main &gt; header &gt; div &gt; a:nth-child(2)');
function f(i) {
$ .post(&quot;/api/feed/delete/&quot;+ $(l[i]).attr('data-feed-id'), function() {
console.log(i);
if(i&lt;l.length-1)setTimeout(`f(${i+1})`,200);
})
}
f(0);
</code></pre>
<ol start="6">
<li>如果出现 <code>503</code> 界面重新再次<strong>重复上述过程</strong>。</li>
</ol>
<p>直到删完为止，重新加载整个界面，建议重启浏览器。</p>
<p>最后就完成了删犇的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于BFS]]></title>
        <id>https://zhanglinquan.github.io/post/about-bfs</id>
        <link href="https://zhanglinquan.github.io/post/about-bfs">
        </link>
        <updated>2020-03-06T12:57:43.000Z</updated>
        <content type="html"><![CDATA[<p><s>他死了</s><br>
BFS，即宽度优先搜索（balabala不讲无意义内容）<br>
核心：用一个队列来记录“待办事项”，用最短路来举个例子，代码如下</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int dx[5]={0,1,0,0,-1};
int dy[5]={0,0,-1,1,0};
int a[1001][1001],q[250000][10];
int sx,sy,ex,ey;
void input(int n,int m){
	char tmp;
	memset(a,-1,sizeof(a));
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;tmp;
			if(tmp=='.') a[i][j]=0;
			if(tmp=='#') a[i][j]=-1;
			if(tmp=='*'){
				a[i][j]=0;
				ex=i;
				ey=j;
			}
			if(tmp=='@'){
				a[i][j]=0;
				sx=i;
				sy=j;
			}
		}
	}
}
int main(){
	int h=1,t=1,n,m;
	cin&gt;&gt;n&gt;&gt;m;
	input(n,m);
	q[1][0]=0;
	q[1][1]=sx;//初始化“待办事项
	q[1][2]=sy;//同上
	a[1][1]=-1;
	while(h&lt;=t){
		if(q[h][1]==ex&amp;&amp;q[h][2]==ey){//达到目标
			cout&lt;&lt;q[h][0]&lt;&lt;endl;
			return 0;
		}
		for(int i=1;i&lt;=4;i++){
			int x,y;
			x=q[h][1]+dx[i];//拿到事情
			y=q[h][2]+dy[i];//同上
			if(a[x][y]==0){//做事
				t++;
				q[t][0]=q[h][0]+1;//产生新事
				q[t][1]=x;//同上
				q[t][2]=y;//同上
				a[x][y]=-1;
			}
		}
		h++;//做完了一件事
	}
    //无解
	return 0;
}
</code></pre>
<p>这里面没有用STL中的queue，但原理相同。<br>
代码中每次穷举的是步数（即离终点的距离），一次while穷举一个步数。<br>
可以看到，队列在while循环做完之前不为空（即有效解一定在穷举完所有步数之前得到），所以BFS的解一般是在循环内产生。<br>
然后，我们用深搜（DFS）来实现一下</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[105][105],d[105][105],n,m;
void dg(int dep,int i,int j){
	if(dep&lt;d[i][j]&amp;&amp;dep&lt;200){
		d[i][j]=dep;
		if(a[i][j+1]==0) dg(dep+1,i,j+1);
		if(a[i+1][j]==0) dg(dep+1,i+1,j);
		if(a[i][j-1]==0) dg(dep+1,i,j-1);
		if(a[i-1][j]==0) dg(dep+1,i-1,j);
	}
}
void input(int n,int m){
	char tmp;
	memset(a,-1,sizeof(a));
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;tmp;
			if(tmp=='.') a[i][j]=0;
			if(tmp=='#') a[i][j]=-1;
			d[i][j]=INT_MAX;
		}
	}
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	input(n,m);
	dg(1,1,1);
	cout&lt;&lt;d[n][m]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>可以发现，DFS慢在于需要回溯，而且不做到底不回头，举个例子，正确路径是右右右右，而DFS永远先穷举左，产生大量无意义劳动，而BFS只需要循环4*4=16次，速度进步巨大。（所以DFS要加玄学限制:dep&lt;200）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次做工程的成果]]></title>
        <id>https://zhanglinquan.github.io/post/di-yi-ci-zuo-gong-cheng-de-cheng-guo</id>
        <link href="https://zhanglinquan.github.io/post/di-yi-ci-zuo-gong-cheng-de-cheng-guo">
        </link>
        <updated>2020-03-05T12:08:02.000Z</updated>
        <content type="html"><![CDATA[<p>寒假里摸鱼的成果</p>
<pre><code class="language-cpp">/*
坑点大全：
1.地图是25*25的，不是27*27的
2.x,y是行，列，不是列，行（可能某些地方做了转换） 
3.p1在代码中还记作p1，但p2记作p0
4.p2(p0)代码中变量为p1的后面加数字1
5.重要！！重要！！！！重要！！！这个程序分4个线程，分别是打印地图，main函数，p1键盘侦测，p2（p0）键盘侦测
6.原来想做的事战略游戏（放置方块）（像皇室战争）所以障碍才分1-4，1、2归P1，3、4归P2，后来改成走迷宫，添加了6目标方块，还可以放障碍（1-4），后来变成放地雷，再变成自动生成地雷，最后水平不足，变成
自动生成障碍。
7.请未来的自己帮忙，其实自动行走是bug。（2020.1.25） 
*/ 
#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt; 
#include&lt;time.h&gt;
COORD coord;
using namespace std;
const int mapx=27;
bool stop=false;
int maps[mapx][mapx];
HANDLE hCon;
int p1ott,p1btt,p2ott,p2btt,pn=1,x=2,y=2,ops,ops1,x1=2,y1=2;
enum Color {DARKBLUE=1,DARKGREEN,DARKTEAL,DARKRED,DARKPINK,DARKYELLOW,GRAY,DARKGRAY,BLUE,GREEN,TEAL,RED,PINK,YELLOW,WHITE};
void window(){
	HANDLE handle=GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_CURSOR_INFO CursorInfo;
	GetConsoleCursorInfo(handle,&amp;CursorInfo);
	CursorInfo.bVisible=false;
	SetConsoleCursorInfo(handle,&amp;CursorInfo); 
}
void SetColor(Color c){
    if(hCon==NULL)
    	hCon=GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hCon,c);
}
void GoToxy(int x,int y){
    coord.X=x;
    coord.Y=y;
    HANDLE a=GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleCursorPosition(a,coord);
}
int clrscr(){ 
	HANDLE hndl=GetStdHandle(STD_OUTPUT_HANDLE); 
	CONSOLE_SCREEN_BUFFER_INFO csbi; 
	GetConsoleScreenBufferInfo(hndl,&amp;csbi); 
	DWORD written; 
	DWORD N=csbi.dwSize.X*csbi.dwCursorPosition.Y+csbi.dwCursorPosition.X+1; 
	COORD curhome={0,0}; 
	FillConsoleOutputCharacter(hndl,' ',N,curhome,&amp;written); 
	csbi.srWindow.Bottom-=csbi.srWindow.Top; 
	csbi.srWindow.Top=0; 
	SetConsoleWindowInfo(hndl,TRUE,&amp;csbi.srWindow); 
	SetConsoleCursorPosition(hndl,curhome); 
	return 0; 
}
char keyboard(){
	if (GetAsyncKeyState(VK_UP)&amp;0x8000)  
		return 'w';
    else if (GetAsyncKeyState(VK_DOWN)&amp;0x8000)  
		return 's';
    else if (GetAsyncKeyState(VK_LEFT)&amp;0x8000)
        return 'a';
    else if (GetAsyncKeyState(VK_RIGHT)&amp;0x8000)  
        return 'd';
    else if (GetAsyncKeyState(VK_NUMPAD8)&amp;0x8000)  
        return 'i';
    else if (GetAsyncKeyState(VK_NUMPAD5)&amp;0x8000)  
    	return 'k';
    else if (GetAsyncKeyState(VK_NUMPAD4)&amp;0x8000)
        return 'j';
    else if (GetAsyncKeyState(VK_NUMPAD6)&amp;0x8000)  
        return 'l';
}
char to_ch_map(int n){
	switch(n){
		case 0:return '.';
		case 1:return '@';
		case 2:return '#';
		case 3:return '$';
		case 4:return '%';
		case 5:return '=';
		case 6:return '*';
		case 7:return '&amp;';
	}
}
void outputmap(){
	int c;
	char c2;
	char op;
	for(int i=1;i&lt;mapx;i++){
		for(int j=1;j&lt;mapx;j++){
			GoToxy(j,i);
			c=maps[i][j];
			c2=to_ch_map(c);
			if(maps[i][j]==5||maps[i][j]==7){
				SetColor(RED);
			}
			printf(&quot;%c&quot;,c2);
			SetColor(YELLOW);
		}
		printf(&quot;\n&quot;);
	}
}
void p1(){
	char op;
	int oops=ops;
	int ox=1,oy=1,th;
	ox=x;oy=y;
	op=keyboard();
	switch(op){
		case 'w':x--;ops=0;break;
		case 's':x++;ops=0;break;
		case 'a':y--;ops=0;break;
		case 'd':y++;ops=0;break;
	}
	if(maps[x][y]!=0&amp;&amp;maps[x][y]!=6){
		x=ox;
		y=oy;
	}
	if(oops==0&amp;&amp;ops==0) maps[ox][oy]=0;
	if(ops==0) maps[x][y]=5;
}
void p2(){
	char op1;
	int oops1=ops1;
	int ox1=1,oy1=1,th1;
	ox1=x1;oy1=y1;
	op1=keyboard();
	switch(op1){
		case 'i':x1--;ops=0;break;
		case 'k':x1++;ops=0;break;
		case 'j':y1--;ops=0;break;
		case 'l':y1++;ops=0;break;
	}
	if(maps[x1][y1]!=0&amp;&amp;maps[x1][y1]!=6){
		x1=ox1;
		y1=oy1;
	}
	if(oops1==0&amp;&amp;ops1==0) maps[ox1][oy1]=0;
	if(ops1==0) maps[x1][y1]=7;
}
void start(){
	srand(time(0));
	memset(maps,rand(),sizeof(maps));
	memset(maps,0,sizeof(maps));
	maps[11][11]=6;
	maps[10][1]=1;
	maps[11][1]=1;
	maps[8][2]=1;
	maps[13][2]=1;
	maps[10][mapx-2]=1;
	maps[11][mapx-2]=1;
	maps[8][mapx-1]=1;
	maps[13][mapx-1]=1;
	maps[11][10]=2;
	maps[11][12]=2;
	maps[10][11]=2;
	for(int i=1;i&lt;=mapx-1;i++){
		maps[1][i]=2;
		maps[i][1]=2;
	}
	for(int i=1;i&lt;=mapx-1;i++){
		maps[i][mapx-1]=2;
		maps[mapx-1][i]=2;
	}
	srand(time(0));
	for(int i=1;i&lt;mapx-1;i++){
		for(int j=1;j&lt;mapx-1;j++){
			if(j==11||i==11) continue;
			if(rand()%10==0) maps[i][j]==4;
			if(rand()%13==0) maps[i][j]=1;
			if(rand()%75==0) maps[i][j]=3;
		}
	}
}
void th1(){
	while(!stop){
		outputmap();
	}
	clrscr();
	system(&quot;color C4&quot;);
}
void th2(){
	while(!stop){
		p2();
		Sleep(100);
	}
	clrscr();
	system(&quot;color C4&quot;);
}
void th3(){
	while(!stop){
		p1();
		Sleep(100);
	}
	clrscr();
	system(&quot;color C4&quot;);
}
int main(){
	window();
	start();
	thread t(&amp;th1);
	thread t1(&amp;th2);
	thread t3(&amp;th3);
	while(!stop){
		if(maps[11][11]!=5&amp;&amp;maps[11][11]!=7&amp;&amp;maps[11][11]!=6){
			maps[11][11]=6;
			cout&lt;&lt;&quot;this block must be 6!!&quot;&lt;&lt;endl;
		}
		if(maps[11][11]==5){
			stop=!stop;
			clrscr();
			Sleep(1000);
			system(&quot;color 07&quot;);
			cout&lt;&lt;&quot;p1 WIN&quot;&lt;&lt;endl;
			system(&quot;pause&quot;);
			exit(0);
		}
		if(maps[11][11]==7){
			stop=!stop;
			clrscr();
			Sleep(1000);
			system(&quot;color 07&quot;);
			cout&lt;&lt;&quot;p2 WIN&quot;&lt;&lt;endl;
			system(&quot;pause&quot;);
			exit(0);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>